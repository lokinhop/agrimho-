<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Consci√™ncia Feminina Negra - A Jornada de Ayodele</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #0a0a0a;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            color: #fff;
        }

        #game-container {
            position: relative;
            width: 500px;
            height: 600px;
            background-color: #121212;
            border: 5px solid #8e44ad;
            box-shadow: 0 0 20px rgba(142, 68, 173, 0.5);
        }

        #maze {
            position: absolute;
            width: 100%;
            height: 80%;
            background-color: #121212;
        }

        .wall {
            position: absolute;
            background-color: #8e44ad;
            border-radius: 5px;
        }

        .dot {
            position: absolute;
            width: 8px;
            height: 8px;
            background-color: #f1c40f;
            border-radius: 50%;
        }

        .power-pellet {
            position: absolute;
            width: 16px;
            height: 16px;
            background-color: #e74c3c;
            border-radius: 50%;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        #ayodele {
            position: absolute;
            width: 24px;
            height: 24px;
            background-color: #f39c12;
            border-radius: 50%;
            z-index: 10;
        }

        .obstacle {
            position: absolute;
            width: 24px;
            height: 24px;
            border-radius: 10px 10px 0 0;
            z-index: 5;
        }

        #score-display {
            position: absolute;
            top: 510px;
            left: 20px;
            color: #fff;
            font-size: 18px;
        }

        #lives-display {
            position: absolute;
            top: 540px;
            left: 20px;
            color: #fff;
            font-size: 18px;
        }

        #game-over, #win-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #e74c3c;
            font-size: 30px;
            font-weight: bold;
            text-align: center;
            display: none;
            z-index: 20;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            width: 80%;
        }

        #win-screen {
            color: #2ecc71;
        }

        button {
            background-color: #8e44ad;
            color: white;
            border: none;
            padding: 10px 20px;
            margin-top: 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }

        button:hover {
            background-color: #9b59b6;
        }

        #story {
            position: absolute;
            top: 10px;
            left: 20px;
            color: #fff;
            font-size: 14px;
            width: 90%;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="story">Ayodele, uma guerreira ancestral, deve coletar sabedoria e enfrentar obst√°culos para fortalecer sua consci√™ncia negra feminina.</div>
        <div id="score-display">Sabedoria: 0</div>
        <div id="lives-display">For√ßa Ancestral: 3</div>
        <div id="maze"></div>
        <div id="ayodele"></div>
        <div id="game-over">
            FIM DE JOGO!<br>
            Mas a luta continua...<br>
            <button onclick="resetGame()">Recome√ßar</button>
        </div>
        <div id="win-screen">
            VIT√ìRIA! üéâ<br>
            Ayodele fortaleceu sua consci√™ncia e ancestralidade!<br>
            <button onclick="resetGame()">Jogar Novamente</button>
        </div>
    </div>

    <script>
        // Configura√ß√µes do jogo
        const config = {
            speed: 3,
            obstacleSpeed: 1.5,
            dotSize: 8,
            pelletSize: 16,
            cellSize: 25
        };

        // Estado do jogo
        const gameState = {
            score: 0,
            lives: 3,
            gameOver: false,
            win: false,
            ayodele: {
                x: 240,
                y: 400,
                direction: 'right',
                nextDirection: 'right',
                mouthOpen: true
            },
            obstacles: [
                { x: 180, y: 180, color: '#c0392b', direction: 'up', speed: config.obstacleSpeed, type: 'machismo' },
                { x: 240, y: 180, color: '#3498db', direction: 'left', speed: config.obstacleSpeed, type: 'racismo' },
                { x: 300, y: 180, color: '#e74c3c', direction: 'right', speed: config.obstacleSpeed, type: 'viol√™ncia' }
            ],
            dots: [],
            pellets: [],
            walls: []
        };

        // Elementos do DOM
        const gameContainer = document.getElementById('game-container');
        const maze = document.getElementById('maze');
        const ayodeleElement = document.getElementById('ayodele');
        const scoreDisplay = document.getElementById('score-display');
        const livesDisplay = document.getElementById('lives-display');
        const gameOverDisplay = document.getElementById('game-over');
        const winDisplay = document.getElementById('win-screen');

        // Inicializa o labirinto
        function initializeMaze() {
            maze.innerHTML = '';
            gameState.dots = [];
            gameState.pellets = [];
            gameState.walls = [];

            // Cria paredes (labirinto tem√°tico)
            createWalls();

            // Cria pontos (sabedoria ancestral)
            createDots();

            // Cria power pellets (empoderamento)
            createPellets();

            // Posiciona Ayodele
            ayodeleElement.style.left = gameState.ayodele.x + 'px';
            ayodeleElement.style.top = gameState.ayodele.y + 'px';

            // Cria obst√°culos
            createObstacles();
        }

        function createWalls() {
            // Paredes externas
            addWall(0, 0, 500, 20); // Topo
            addWall(0, 480, 500, 20); // Base
            addWall(0, 0, 20, 500); // Esquerda
            addWall(480, 0, 20, 500); // Direita

            // Labirinto tem√°tico (representando desafios)
            addWall(100, 60, 300, 20); // Barreira do racismo estrutural
            addWall(100, 140, 300, 20); // Barreira do machismo
            addWall(60, 100, 20, 200); // Barreira da viol√™ncia
            addWall(420, 100, 20, 200); // Barreira da desigualdade
            addWall(200, 220, 100, 40); // Espa√ßo sagrado (√°rea protegida)
        }

        function addWall(x, y, width, height) {
            const wall = document.createElement('div');
            wall.className = 'wall';
            wall.style.left = x + 'px';
            wall.style.top = y + 'px';
            wall.style.width = width + 'px';
            wall.style.height = height + 'px';
            maze.appendChild(wall);

            gameState.walls.push({ x, y, width, height });
        }

        function createDots() {
            // Pontos representando sabedoria ancestral
            for (let y = 40; y < 460; y += config.cellSize) {
                for (let x = 40; x < 460; x += config.cellSize) {
                    if (!isWallAt(x, y, config.dotSize, config.dotSize)) {
                        const dot = document.createElement('div');
                        dot.className = 'dot';
                        dot.style.left = (x - config.dotSize/2) + 'px';
                        dot.style.top = (y - config.dotSize/2) + 'px';
                        maze.appendChild(dot);

                        gameState.dots.push({ 
                            x: x - config.dotSize/2, 
                            y: y - config.dotSize/2,
                            element: dot,
                            collected: false
                        });
                    }
                }
            }
        }

        function createPellets() {
            // Power pellets representando momentos de empoderamento
            const positions = [
                { x: 60, y: 60 },  // Sabedoria de Dandara
                { x: 440, y: 60 },  // For√ßa de Aqualtune
                { x: 60, y: 440 },  // Resist√™ncia de Carolina Maria de Jesus
                { x: 440, y: 440 }   // Luta de Marielle Franco
            ];

            positions.forEach(pos => {
                const pellet = document.createElement('div');
                pellet.className = 'power-pellet';
                pellet.style.left = (pos.x - config.pelletSize/2) + 'px';
                pellet.style.top = (pos.y - config.pelletSize/2) + 'px';
                maze.appendChild(pellet);

                gameState.pellets.push({
                    x: pos.x - config.pelletSize/2,
                    y: pos.y - config.pelletSize/2,
                    element: pellet,
                    collected: false
                });
            });
        }

        function createObstacles() {
            gameState.obstacles.forEach(obstacle => {
                const obstacleElement = document.createElement('div');
                obstacleElement.className = 'obstacle';
                obstacleElement.style.left = obstacle.x + 'px';
                obstacleElement.style.top = obstacle.y + 'px';
                obstacleElement.style.backgroundColor = obstacle.color;
                maze.appendChild(obstacleElement);
                obstacle.element = obstacleElement;
            });
        }

        function isWallAt(x, y, width, height) {
            for (const wall of gameState.walls) {
                if (x + width > wall.x && x < wall.x + wall.width &&
                    y + height > wall.y && y < wall.y + wall.height) {
                    return true;
                }
            }
            return false;
        }

        // Controles do teclado
        document.addEventListener('keydown', (e) => {
            if (gameState.gameOver || gameState.win) return;

            switch (e.key) {
                case 'ArrowUp':
                    gameState.ayodele.nextDirection = 'up';
                    break;
                case 'ArrowDown':
                    gameState.ayodele.nextDirection = 'down';
                    break;
                case 'ArrowLeft':
                    gameState.ayodele.nextDirection = 'left';
                    break;
                case 'ArrowRight':
                    gameState.ayodele.nextDirection = 'right';
                    break;
            }
        });

        // Atualiza o jogo
        function update() {
            if (gameState.gameOver || gameState.win) return;

            moveAyodele();
            moveObstacles();
            checkCollisions();
            checkDots();
            checkPellets();
            animateAyodele();
            checkWin();

            // Atualiza displays
            scoreDisplay.textContent = `Sabedoria: ${gameState.score}`;
            livesDisplay.textContent = `For√ßa Ancestral: ${gameState.lives}`;
        }

        function moveAyodele() {
            const ayodele = gameState.ayodele;
            const size = 24;

            // Tenta mudar de dire√ß√£o
            const nextDir = ayodele.nextDirection;
            let canChangeDirection = false;

            switch (nextDir) {
                case 'up':
                    if (!isWallAt(ayodele.x, ayodele.y - config.speed, size, size)) {
                        canChangeDirection = true;
                    }
                    break;
                case 'down':
                    if (!isWallAt(ayodele.x, ayodele.y + config.speed, size, size)) {
                        canChangeDirection = true;
                    }
                    break;
                case 'left':
                    if (!isWallAt(ayodele.x - config.speed, ayodele.y, size, size)) {
                        canChangeDirection = true;
                    }
                    break;
                case 'right':
                    if (!isWallAt(ayodele.x + config.speed, ayodele.y, size, size)) {
                        canChangeDirection = true;
                    }
                    break;
            }

            if (canChangeDirection) {
                ayodele.direction = nextDir;
            }

            // Movimenta Ayodele
            switch (ayodele.direction) {
                case 'up':
                    if (!isWallAt(ayodele.x, ayodele.y - config.speed, size, size)) {
                        ayodele.y -= config.speed;
                    }
                    break;
                case 'down':
                    if (!isWallAt(ayodele.x, ayodele.y + config.speed, size, size)) {
                        ayodele.y += config.speed;
                    }
                    break;
                case 'left':
                    if (!isWallAt(ayodele.x - config.speed, ayodele.y, size, size)) {
                        ayodele.x -= config.speed;
                    }
                    break;
                case 'right':
                    if (!isWallAt(ayodele.x + config.speed, ayodele.y, size, size)) {
                        ayodele.x += config.speed;
                    }
                    break;
            }

            // Teleporte nos t√∫neis (conex√£o com a ancestralidade)
            if (ayodele.x < -size) {
                ayodele.x = gameContainer.offsetWidth;
            } else if (ayodele.x > gameContainer.offsetWidth) {
                ayodele.x = -size;
            }

            // Atualiza posi√ß√£o no DOM
            ayodeleElement.style.left = ayodele.x + 'px';
            ayodeleElement.style.top = ayodele.y + 'px';
        }

        function moveObstacles() {
            gameState.obstacles.forEach(obstacle => {
                const size = 24;
                let directions = ['up', 'down', 'left', 'right'];

                // Remove a dire√ß√£o oposta para evitar movimento oscilante
                directions = directions.filter(dir => {
                    return !(dir === 'up' && obstacle.direction === 'down') &&
                           !(dir === 'down' && obstacle.direction === 'up') &&
                           !(dir === 'left' && obstacle.direction === 'right') &&
                           !(dir === 'right' && obstacle.direction === 'left');
                });

                // Tenta continuar na mesma dire√ß√£o
                if (!isWallInDirection(obstacle, obstacle.direction)) {
                    moveObstacle(obstacle, obstacle.direction);
                    return;
                }

                // Se n√£o puder, escolhe uma dire√ß√£o aleat√≥ria v√°lida
                const validDirections = directions.filter(dir => !isWallInDirection(obstacle, dir));

                if (validDirections.length > 0) {
                    const randomDir = validDirections[Math.floor(Math.random() * validDirections.length)];
                    obstacle.direction = randomDir;
                    moveObstacle(obstacle, randomDir);
                }
            });
        }

        function isWallInDirection(obstacle, direction) {
            const size = 24;
            const speed = obstacle.speed;

            switch (direction) {
                case 'up':
                    return isWallAt(obstacle.x, obstacle.y - speed, size, size);
                case 'down':
                    return isWallAt(obstacle.x, obstacle.y + speed, size, size);
                case 'left':
                    return isWallAt(obstacle.x - speed, obstacle.y, size, size);
                case 'right':
                    return isWallAt(obstacle.x + speed, obstacle.y, size, size);
            }
            return true;
        }

        function moveObstacle(obstacle, direction) {
            const size = 24;

            switch (direction) {
                case 'up':
                    obstacle.y -= obstacle.speed;
                    break;
                case 'down':
                    obstacle.y += obstacle.speed;
                    break;
                case 'left':
                    obstacle.x -= obstacle.speed;
                    break;
                case 'right':
                    obstacle.x += obstacle.speed;
                    break;
            }

            // Teleporte nos t√∫neis (para obst√°culos tamb√©m)
            if (obstacle.x < -size) {
                obstacle.x = gameContainer.offsetWidth;
            } else if (obstacle.x > gameContainer.offsetWidth) {
                obstacle.x = -size;
            }

            // Atualiza posi√ß√£o no DOM
            obstacle.element.style.left = obstacle.x + 'px';
            obstacle.element.style.top = obstacle.y + 'px';
        }

        function checkCollisions() {
            const ayodele = gameState.ayodele;
            const ayodeleSize = 24;

            gameState.obstacles.forEach(obstacle => {
                const obstacleSize = 24;

                // Verifica colis√£o com Ayodele
                if (Math.abs(ayodele.x - obstacle.x) < ayodeleSize/2 + obstacleSize/2 &&
                    Math.abs(ayodele.y - obstacle.y) < ayodeleSize/2 + obstacleSize/2) {
                    
                    // Perde uma vida
                    gameState.lives--;
                    
                    if (gameState.lives <= 0) {
                        gameOver();
                    } else {
                        // Reseta posi√ß√µes
                        resetPositions();
                    }
                }
            });
        }

        function checkDots() {
            const ayodele = gameState.ayodele;
            const ayodeleSize = 24;

            gameState.dots.forEach(dot => {
                if (!dot.collected) {
                    const dotSize = config.dotSize;
                    const dotCenterX = dot.x + dotSize/2;
                    const dotCenterY = dot.y + dotSize/2;
                    const ayodeleCenterX = ayodele.x + ayodeleSize/2;
                    const ayodeleCenterY = ayodele.y + ayodeleSize/2;

                    if (Math.abs(ayodeleCenterX - dotCenterX) < ayodeleSize/2 + dotSize/2 &&
                        Math.abs(ayodeleCenterY - dotCenterY) < ayodeleSize/2 + dotSize/2) {

                        dot.collected = true;
                        dot.element.style.display = 'none';
                        gameState.score += 10;
                    }
                }
            });
        }

        function checkPellets() {
            const ayodele = gameState.ayodele;
            const ayodeleSize = 24;

            gameState.pellets.forEach(pellet => {
                if (!pellet.collected) {
                    const pelletSize = config.pelletSize;
                    const pelletCenterX = pellet.x + pelletSize/2;
                    const pelletCenterY = pellet.y + pelletSize/2;
                    const ayodeleCenterX = ayodele.x + ayodeleSize/2;
                    const ayodeleCenterY = ayodele.y + ayodeleSize/2;

                    if (Math.abs(ayodeleCenterX - pelletCenterX) < ayodeleSize/2 + pelletSize/2 &&
                        Math.abs(ayodeleCenterY - pelletCenterY) < ayodeleSize/2 + pelletSize/2) {

                        pellet.collected = true;
                        pellet.element.style.display = 'none';
                        gameState.score += 50;
                    }
                }
            });
        }

        function checkWin() {
            const allDotsCollected = gameState.dots.every(dot => dot.collected);
            const allPelletsCollected = gameState.pellets.every(pellet => pellet.collected);

            if (allDotsCollected && allPelletsCollected) {
                gameState.win = true;
                winDisplay.style.display = 'block';
            }
        }

        function animateAyodele() {
            const ayodele = gameState.ayodele;

            // Alterna a boca aberta/fechada (representando fala e a√ß√£o)
            ayodele.mouthOpen = !ayodele.mouthOpen;

            // Cria o efeito visual da boca de Ayodele
            if (ayodele.mouthOpen) {
                ayodeleElement.style.clipPath = getPacmanClipPath(ayodele.direction, 35);
            } else {
                ayodeleElement.style.clipPath = getPacmanClipPath(ayodele.direction, 0);
            }
        }

        function getPacmanClipPath(direction, angle) {
            switch (direction) {
                case 'right':
                    return `polygon(50% 50%, 100% ${50 - angle}%, 100% ${50 + angle}%)`;
                case 'left':
                    return `polygon(50% 50%, 0% ${50 + angle}%, 0% ${50 - angle}%)`;
                case 'up':
                    return `polygon(50% 50%, ${50 + angle}% 0%, ${50 - angle}% 0%)`;
                case 'down':
                    return `polygon(50% 50%, ${50 - angle}% 100%, ${50 + angle}% 100%)`;
                default:
                    return '';
            }
        }

        function resetPositions() {
            // Reseta Ayodele
            gameState.ayodele.x = 240;
            gameState.ayodele.y = 400;
            gameState.ayodele.direction = 'right';
            gameState.ayodele.nextDirection = 'right';

            // Reseta obst√°culos
            gameState.obstacles[0].x = 180;
            gameState.obstacles[0].y = 180;
            gameState.obstacles[1].x = 240;
            gameState.obstacles[1].y = 180;
            gameState.obstacles[2].x = 300;
            gameState.obstacles[2].y = 180;
        }

        function gameOver() {
            gameState.gameOver = true;
            gameOverDisplay.style.display = 'block';
        }

        function resetGame() {
            gameState.score = 0;
            gameState.lives = 3;
            gameState.gameOver = false;
            gameState.win = false;
            gameOverDisplay.style.display = 'none';
            winDisplay.style.display = 'none';
            initializeMaze();
        }

        // Inicializa o jogo
        initializeMaze();

        // Loop do jogo
        setInterval(update, 1000/60); // 60 FPS
    </script>
</body>
</html><!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Consci√™ncia Feminina Negra - A Jornada de Ayodele</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #0a0a0a;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            color: #fff;
        }

        #game-container {
            position: relative;
            width: 500px;
            height: 600px;
            background-color: #121212;
            border: 5px solid #8e44ad;
            box-shadow: 0 0 20px rgba(142, 68, 173, 0.5);
        }

        #maze {
            position: absolute;
            width: 100%;
            height: 80%;
            background-color: #121212;
        }

        .wall {
            position: absolute;
            background-color: #8e44ad;
            border-radius: 5px;
        }

        .dot {
            position: absolute;
            width: 8px;
            height: 8px;
            background-color: #f1c40f;
            border-radius: 50%;
        }

        .power-pellet {
            position: absolute;
            width: 16px;
            height: 16px;
            background-color: #e74c3c;
            border-radius: 50%;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        #ayodele {
            position: absolute;
            width: 24px;
            height: 24px;
            background-color: #f39c12;
            border-radius: 50%;
            z-index: 10;
        }

        .obstacle {
            position: absolute;
            width: 24px;
            height: 24px;
            border-radius: 10px 10px 0 0;
            z-index: 5;
        }

        #score-display {
            position: absolute;
            top: 510px;
            left: 20px;
            color: #fff;
            font-size: 18px;
        }

        #lives-display {
            position: absolute;
            top: 540px;
            left: 20px;
            color: #fff;
            font-size: 18px;
        }

        #game-over, #win-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #e74c3c;
            font-size: 30px;
            font-weight: bold;
            text-align: center;
            display: none;
            z-index: 20;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            width: 80%;
        }

        #win-screen {
            color: #2ecc71;
        }

        button {
            background-color: #8e44ad;
            color: white;
            border: none;
            padding: 10px 20px;
            margin-top: 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }

        button:hover {
            background-color: #9b59b6;
        }

        #story {
            position: absolute;
            top: 10px;
            left: 20px;
            color: #fff;
            font-size: 14px;
            width: 90%;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="story">Ayodele, uma guerreira ancestral, deve coletar sabedoria e enfrentar obst√°culos para fortalecer sua consci√™ncia negra feminina.</div>
        <div id="score-display">Sabedoria: 0</div>
        <div id="lives-display">For√ßa Ancestral: 3</div>
        <div id="maze"></div>
        <div id="ayodele"></div>
        <div id="game-over">
            FIM DE JOGO!<br>
            Mas a luta continua...<br>
            <button onclick="resetGame()">Recome√ßar</button>
        </div>
        <div id="win-screen">
            VIT√ìRIA! üéâ<br>
            Ayodele fortaleceu sua consci√™ncia e ancestralidade!<br>
            <button onclick="resetGame()">Jogar Novamente</button>
        </div>
    </div>

    <script>
        // Configura√ß√µes do jogo
        const config = {
            speed: 3,
            obstacleSpeed: 1.5,
            dotSize: 8,
            pelletSize: 16,
            cellSize: 25
        };

        // Estado do jogo
        const gameState = {
            score: 0,
            lives: 3,
            gameOver: false,
            win: false,
            ayodele: {
                x: 240,
                y: 400,
                direction: 'right',
                nextDirection: 'right',
                mouthOpen: true
            },
            obstacles: [
                { x: 180, y: 180, color: '#c0392b', direction: 'up', speed: config.obstacleSpeed, type: 'machismo' },
                { x: 240, y: 180, color: '#3498db', direction: 'left', speed: config.obstacleSpeed, type: 'racismo' },
                { x: 300, y: 180, color: '#e74c3c', direction: 'right', speed: config.obstacleSpeed, type: 'viol√™ncia' }
            ],
            dots: [],
            pellets: [],
            walls: []
        };

        // Elementos do DOM
        const gameContainer = document.getElementById('game-container');
        const maze = document.getElementById('maze');
        const ayodeleElement = document.getElementById('ayodele');
        const scoreDisplay = document.getElementById('score-display');
        const livesDisplay = document.getElementById('lives-display');
        const gameOverDisplay = document.getElementById('game-over');
        const winDisplay = document.getElementById('win-screen');

        // Inicializa o labirinto
        function initializeMaze() {
            maze.innerHTML = '';
            gameState.dots = [];
            gameState.pellets = [];
            gameState.walls = [];

            // Cria paredes (labirinto tem√°tico)
            createWalls();

            // Cria pontos (sabedoria ancestral)
            createDots();

            // Cria power pellets (empoderamento)
            createPellets();

            // Posiciona Ayodele
            ayodeleElement.style.left = gameState.ayodele.x + 'px';
            ayodeleElement.style.top = gameState.ayodele.y + 'px';

            // Cria obst√°culos
            createObstacles();
        }

        function createWalls() {
            // Paredes externas
            addWall(0, 0, 500, 20); // Topo
            addWall(0, 480, 500, 20); // Base
            addWall(0, 0, 20, 500); // Esquerda
            addWall(480, 0, 20, 500); // Direita

            // Labirinto tem√°tico (representando desafios)
            addWall(100, 60, 300, 20); // Barreira do racismo estrutural
            addWall(100, 140, 300, 20); // Barreira do machismo
            addWall(60, 100, 20, 200); // Barreira da viol√™ncia
            addWall(420, 100, 20, 200); // Barreira da desigualdade
            addWall(200, 220, 100, 40); // Espa√ßo sagrado (√°rea protegida)
        }

        function addWall(x, y, width, height) {
            const wall = document.createElement('div');
            wall.className = 'wall';
            wall.style.left = x + 'px';
            wall.style.top = y + 'px';
            wall.style.width = width + 'px';
            wall.style.height = height + 'px';
            maze.appendChild(wall);

            gameState.walls.push({ x, y, width, height });
        }

        function createDots() {
            // Pontos representando sabedoria ancestral
            for (let y = 40; y < 460; y += config.cellSize) {
                for (let x = 40; x < 460; x += config.cellSize) {
                    if (!isWallAt(x, y, config.dotSize, config.dotSize)) {
                        const dot = document.createElement('div');
                        dot.className = 'dot';
                        dot.style.left = (x - config.dotSize/2) + 'px';
                        dot.style.top = (y - config.dotSize/2) + 'px';
                        maze.appendChild(dot);

                        gameState.dots.push({ 
                            x: x - config.dotSize/2, 
                            y: y - config.dotSize/2,
                            element: dot,
                            collected: false
                        });
                    }
                }
            }
        }

        function createPellets() {
            // Power pellets representando momentos de empoderamento
            const positions = [
                { x: 60, y: 60 },  // Sabedoria de Dandara
                { x: 440, y: 60 },  // For√ßa de Aqualtune
                { x: 60, y: 440 },  // Resist√™ncia de Carolina Maria de Jesus
                { x: 440, y: 440 }   // Luta de Marielle Franco
            ];

            positions.forEach(pos => {
                const pellet = document.createElement('div');
                pellet.className = 'power-pellet';
                pellet.style.left = (pos.x - config.pelletSize/2) + 'px';
                pellet.style.top = (pos.y - config.pelletSize/2) + 'px';
                maze.appendChild(pellet);

                gameState.pellets.push({
                    x: pos.x - config.pelletSize/2,
                    y: pos.y - config.pelletSize/2,
                    element: pellet,
                    collected: false
                });
            });
        }

        function createObstacles() {
            gameState.obstacles.forEach(obstacle => {
                const obstacleElement = document.createElement('div');
                obstacleElement.className = 'obstacle';
                obstacleElement.style.left = obstacle.x + 'px';
                obstacleElement.style.top = obstacle.y + 'px';
                obstacleElement.style.backgroundColor = obstacle.color;
                maze.appendChild(obstacleElement);
                obstacle.element = obstacleElement;
            });
        }

        function isWallAt(x, y, width, height) {
            for (const wall of gameState.walls) {
                if (x + width > wall.x && x < wall.x + wall.width &&
                    y + height > wall.y && y < wall.y + wall.height) {
                    return true;
                }
            }
            return false;
        }

        // Controles do teclado
        document.addEventListener('keydown', (e) => {
            if (gameState.gameOver || gameState.win) return;

            switch (e.key) {
                case 'ArrowUp':
                    gameState.ayodele.nextDirection = 'up';
                    break;
                case 'ArrowDown':
                    gameState.ayodele.nextDirection = 'down';
                    break;
                case 'ArrowLeft':
                    gameState.ayodele.nextDirection = 'left';
                    break;
                case 'ArrowRight':
                    gameState.ayodele.nextDirection = 'right';
                    break;
            }
        });

        // Atualiza o jogo
        function update() {
            if (gameState.gameOver || gameState.win) return;

            moveAyodele();
            moveObstacles();
            checkCollisions();
            checkDots();
            checkPellets();
            animateAyodele();
            checkWin();

            // Atualiza displays
            scoreDisplay.textContent = `Sabedoria: ${gameState.score}`;
            livesDisplay.textContent = `For√ßa Ancestral: ${gameState.lives}`;
        }

        function moveAyodele() {
            const ayodele = gameState.ayodele;
            const size = 24;

            // Tenta mudar de dire√ß√£o
            const nextDir = ayodele.nextDirection;
            let canChangeDirection = false;

            switch (nextDir) {
                case 'up':
                    if (!isWallAt(ayodele.x, ayodele.y - config.speed, size, size)) {
                        canChangeDirection = true;
                    }
                    break;
                case 'down':
                    if (!isWallAt(ayodele.x, ayodele.y + config.speed, size, size)) {
                        canChangeDirection = true;
                    }
                    break;
                case 'left':
                    if (!isWallAt(ayodele.x - config.speed, ayodele.y, size, size)) {
                        canChangeDirection = true;
                    }
                    break;
                case 'right':
                    if (!isWallAt(ayodele.x + config.speed, ayodele.y, size, size)) {
                        canChangeDirection = true;
                    }
                    break;
            }

            if (canChangeDirection) {
                ayodele.direction = nextDir;
            }

            // Movimenta Ayodele
            switch (ayodele.direction) {
                case 'up':
                    if (!isWallAt(ayodele.x, ayodele.y - config.speed, size, size)) {
                        ayodele.y -= config.speed;
                    }
                    break;
                case 'down':
                    if (!isWallAt(ayodele.x, ayodele.y + config.speed, size, size)) {
                        ayodele.y += config.speed;
                    }
                    break;
                case 'left':
                    if (!isWallAt(ayodele.x - config.speed, ayodele.y, size, size)) {
                        ayodele.x -= config.speed;
                    }
                    break;
                case 'right':
                    if (!isWallAt(ayodele.x + config.speed, ayodele.y, size, size)) {
                        ayodele.x += config.speed;
                    }
                    break;
            }

            // Teleporte nos t√∫neis (conex√£o com a ancestralidade)
            if (ayodele.x < -size) {
                ayodele.x = gameContainer.offsetWidth;
            } else if (ayodele.x > gameContainer.offsetWidth) {
                ayodele.x = -size;
            }

            // Atualiza posi√ß√£o no DOM
            ayodeleElement.style.left = ayodele.x + 'px';
            ayodeleElement.style.top = ayodele.y + 'px';
        }

        function moveObstacles() {
            gameState.obstacles.forEach(obstacle => {
                const size = 24;
                let directions = ['up', 'down', 'left', 'right'];

                // Remove a dire√ß√£o oposta para evitar movimento oscilante
                directions = directions.filter(dir => {
                    return !(dir === 'up' && obstacle.direction === 'down') &&
                           !(dir === 'down' && obstacle.direction === 'up') &&
                           !(dir === 'left' && obstacle.direction === 'right') &&
                           !(dir === 'right' && obstacle.direction === 'left');
                });

                // Tenta continuar na mesma dire√ß√£o
                if (!isWallInDirection(obstacle, obstacle.direction)) {
                    moveObstacle(obstacle, obstacle.direction);
                    return;
                }

                // Se n√£o puder, escolhe uma dire√ß√£o aleat√≥ria v√°lida
                const validDirections = directions.filter(dir => !isWallInDirection(obstacle, dir));

                if (validDirections.length > 0) {
                    const randomDir = validDirections[Math.floor(Math.random() * validDirections.length)];
                    obstacle.direction = randomDir;
                    moveObstacle(obstacle, randomDir);
                }
            });
        }

        function isWallInDirection(obstacle, direction) {
            const size = 24;
            const speed = obstacle.speed;

            switch (direction) {
                case 'up':
                    return isWallAt(obstacle.x, obstacle.y - speed, size, size);
                case 'down':
                    return isWallAt(obstacle.x, obstacle.y + speed, size, size);
                case 'left':
                    return isWallAt(obstacle.x - speed, obstacle.y, size, size);
                case 'right':
                    return isWallAt(obstacle.x + speed, obstacle.y, size, size);
            }
            return true;
        }

        function moveObstacle(obstacle, direction) {
            const size = 24;

            switch (direction) {
                case 'up':
                    obstacle.y -= obstacle.speed;
                    break;
                case 'down':
                    obstacle.y += obstacle.speed;
                    break;
                case 'left':
                    obstacle.x -= obstacle.speed;
                    break;
                case 'right':
                    obstacle.x += obstacle.speed;
                    break;
            }

            // Teleporte nos t√∫neis (para obst√°culos tamb√©m)
            if (obstacle.x < -size) {
                obstacle.x = gameContainer.offsetWidth;
            } else if (obstacle.x > gameContainer.offsetWidth) {
                obstacle.x = -size;
            }

            // Atualiza posi√ß√£o no DOM
            obstacle.element.style.left = obstacle.x + 'px';
            obstacle.element.style.top = obstacle.y + 'px';
        }

        function checkCollisions() {
            const ayodele = gameState.ayodele;
            const ayodeleSize = 24;

            gameState.obstacles.forEach(obstacle => {
                const obstacleSize = 24;

                // Verifica colis√£o com Ayodele
                if (Math.abs(ayodele.x - obstacle.x) < ayodeleSize/2 + obstacleSize/2 &&
                    Math.abs(ayodele.y - obstacle.y) < ayodeleSize/2 + obstacleSize/2) {
                    
                    // Perde uma vida
                    gameState.lives--;
                    
                    if (gameState.lives <= 0) {
                        gameOver();
                    } else {
                        // Reseta posi√ß√µes
                        resetPositions();
                    }
                }
            });
        }

        function checkDots() {
            const ayodele = gameState.ayodele;
            const ayodeleSize = 24;

            gameState.dots.forEach(dot => {
                if (!dot.collected) {
                    const dotSize = config.dotSize;
                    const dotCenterX = dot.x + dotSize/2;
                    const dotCenterY = dot.y + dotSize/2;
                    const ayodeleCenterX = ayodele.x + ayodeleSize/2;
                    const ayodeleCenterY = ayodele.y + ayodeleSize/2;

                    if (Math.abs(ayodeleCenterX - dotCenterX) < ayodeleSize/2 + dotSize/2 &&
                        Math.abs(ayodeleCenterY - dotCenterY) < ayodeleSize/2 + dotSize/2) {

                        dot.collected = true;
                        dot.element.style.display = 'none';
                        gameState.score += 10;
                    }
                }
            });
        }

        function checkPellets() {
            const ayodele = gameState.ayodele;
            const ayodeleSize = 24;

            gameState.pellets.forEach(pellet => {
                if (!pellet.collected) {
                    const pelletSize = config.pelletSize;
                    const pelletCenterX = pellet.x + pelletSize/2;
                    const pelletCenterY = pellet.y + pelletSize/2;
                    const ayodeleCenterX = ayodele.x + ayodeleSize/2;
                    const ayodeleCenterY = ayodele.y + ayodeleSize/2;

                    if (Math.abs(ayodeleCenterX - pelletCenterX) < ayodeleSize/2 + pelletSize/2 &&
                        Math.abs(ayodeleCenterY - pelletCenterY) < ayodeleSize/2 + pelletSize/2) {

                        pellet.collected = true;
                        pellet.element.style.display = 'none';
                        gameState.score += 50;
                    }
                }
            });
        }

        function checkWin() {
            const allDotsCollected = gameState.dots.every(dot => dot.collected);
            const allPelletsCollected = gameState.pellets.every(pellet => pellet.collected);

            if (allDotsCollected && allPelletsCollected) {
                gameState.win = true;
                winDisplay.style.display = 'block';
            }
        }

        function animateAyodele() {
            const ayodele = gameState.ayodele;

            // Alterna a boca aberta/fechada (representando fala e a√ß√£o)
            ayodele.mouthOpen = !ayodele.mouthOpen;

            // Cria o efeito visual da boca de Ayodele
            if (ayodele.mouthOpen) {
                ayodeleElement.style.clipPath = getPacmanClipPath(ayodele.direction, 35);
            } else {
                ayodeleElement.style.clipPath = getPacmanClipPath(ayodele.direction, 0);
            }
        }

        function getPacmanClipPath(direction, angle) {
            switch (direction) {
                case 'right':
                    return `polygon(50% 50%, 100% ${50 - angle}%, 100% ${50 + angle}%)`;
                case 'left':
                    return `polygon(50% 50%, 0% ${50 + angle}%, 0% ${50 - angle}%)`;
                case 'up':
                    return `polygon(50% 50%, ${50 + angle}% 0%, ${50 - angle}% 0%)`;
                case 'down':
                    return `polygon(50% 50%, ${50 - angle}% 100%, ${50 + angle}% 100%)`;
                default:
                    return '';
            }
        }

        function resetPositions() {
            // Reseta Ayodele
            gameState.ayodele.x = 240;
            gameState.ayodele.y = 400;
            gameState.ayodele.direction = 'right';
            gameState.ayodele.nextDirection = 'right';

            // Reseta obst√°culos
            gameState.obstacles[0].x = 180;
            gameState.obstacles[0].y = 180;
            gameState.obstacles[1].x = 240;
            gameState.obstacles[1].y = 180;
            gameState.obstacles[2].x = 300;
            gameState.obstacles[2].y = 180;
        }

        function gameOver() {
            gameState.gameOver = true;
            gameOverDisplay.style.display = 'block';
        }

        function resetGame() {
            gameState.score = 0;
            gameState.lives = 3;
            gameState.gameOver = false;
            gameState.win = false;
            gameOverDisplay.style.display = 'none';
            winDisplay.style.display = 'none';
            initializeMaze();
        }

        // Inicializa o jogo
        initializeMaze();

        // Loop do jogo
        setInterval(update, 1000/60); // 60 FPS
    </script>
</body>
</html>